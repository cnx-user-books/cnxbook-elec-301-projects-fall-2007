<document xmlns="http://cnx.rice.edu/cnxml" xmlns:md="http://cnx.rice.edu/mdml">
  <title>MATLAB EQ: Approach: Use of Frequency Binning to Apply Frequency Gains</title>
  <metadata><md:content-id>undefined</md:content-id><md:title/><md:uuid>672e69f8-5111-4aee-85b9-5d3deb8d32e0</md:uuid>
</metadata>
  <content>
    <para id="id6953839">The main focus of a graphic equalizer is to manipulate different bands of frequencies, and then reconstruct them. Therefore, to manipulate the frequencies, a group of samples were taken, and the Fast Fourier Transform of the sample set was computed. In order to maximize the efficiency of the FFT, a sample set of a power of two was used. FFTs maximize symmetry in the Discrete Fourier Transforms and are best able to do that for signals of power of two lengths. Hence a refresh rate such that 2048 samples were taken in was chosen.</para>
    <para id="id6599981">Once the signal is put into the Fourier domain, we then need to separate the frequencies into the desired bands so that they can be displayed, operated on, and then be displayed in their updated state. To do this we used a binning matrix. The matrix binned according to a logarithmic Q binning pattern. This means it puts the first and 2048th frequency in the first bin, the second, third, 2047th and 2046th frequencies in the second bin and so on and so forth. The matrix below is an example of how a bin matrix would look for an eight bit Fast Fourier Transform. </para>
    <figure id="id6982570"><media id="idp8271232" alt=""><image src="../../media/graphics1-5bee.png" mime-type="image/png" height="43" width="386"/></media>
      <caption>Example of a bin matrix for a length 8 FFT.</caption></figure>
    <para id="id6579758">The code to generate matrices of this form is below.</para>
    <para id="id6905297">
      <code>[n, bin] = histc(freqs, freqbins);</code>
    </para>
    <para id="id6905304">
      <code>bin = bin(:,1:spt/2);</code>
    </para>
    <para id="id6936073">
      <code/>
    </para>
    <para id="id6936080">
      <code>binmatrixa0 = zeros(length(n)-1, length(bin));</code>
    </para>
    <para id="id6906308">
      <code/>
    </para>
    <para id="id6542615">
      <code>for k = 1:(length(n)-1)</code>
    </para>
    <para id="id6542621">
      <code>binmatrixa0(k,:) = bin == k ;</code>
    </para>
    <para id="id6579228">
      <code>end</code>
    </para>
    <para id="id6905978">
      <code/>
    </para>
    <para id="id6905985">
      <code>binmatrixb0 = fliplr(binmatrixa0);</code>
    </para>
    <para id="id6601110">
      <code>binmatrix0 = [binmatrixa0, binmatrixb0]</code>
    </para>
    <para id="id6601117">Once the bins are generated by multiplying the bin matrix with the FFT vector, the binsâ€™ L2 norms are generated and displayed in bar graph form. Then, all the contents of all the bins are multiplied by what the user inputs in the GUI slide bars. The L2 norms are taken again and displayed in a bar graph as well.</para>
    <para id="id6960966">The multiplying the frequency bins by a constant, it is the equivalent of passing the signal through several different ideal band pass filters. This is possible, because the signals are of finite length. Therefore, a discrete sinc of this length can create a perfect discrete band pass filter.</para>
    <para id="id6960977">Once these gains have been applied, the vectors representing each of the bins are recombined to reform a 2048 Fast Fourier Transform vector. The signal is then Inverse Fast Fourier Transformed to allow for the display of the time wave form, and to allow for the application of time domain effects. </para>
    <para id="id6934765">The last problem that needs to be taken into account is the phase. Due to the application of non-uniform gain to the bins, there is phase added to the output waveform. This phase needs to be removed, because the equalizer is supposed to output to speakers, and speakers can only interpret real signals.</para>
  </content>
</document>